use std::io;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;
use std::net::TcpStream;
use hex;
use similar_string::lcs_length;
use serde_json::*;

fn main() {
    menu_art();
    let data = recv_data();
    match serde_json::from_str::<serde_json::Value>(&data) {
        Ok(data) => {
            let path = get_path();
            scan(path, data);
        }
        Err(e) => {
            println!("Error : couldn't parse data !\n{}", e);
        }
    }
}

fn recv_data() -> String {
    println!("Enter the server's address with this format : address:port\nExample : 127.0.0.1:4545\n");
    print!(" >>> ");
    io::stdout().flush().unwrap();
    match get_input() {
        Some(address) => {
            match TcpStream::connect(&address) {
                Ok(mut stream) => {
                    println!("\nConnected to server.");
                    let mut buffer = [0; 100000];
                    match stream.read(&mut buffer) {
                        Ok(bytes) => {
                            if bytes == 0 {
                                    println!("Error : no data received !");
                            } else {
                                if let Ok(data) = std::str::from_utf8(&buffer[..bytes]) {
                                    println!("Database downloaded succesfully.");
                                    return String::from(data);
                                } else {
                                    println!("Error : couldn't decode data !\n{}\n", bytes);
                                }
                            }
                        },
                        Err(e) => {
                            println!("Error : failed to read from socket !\n{}\n", e);
                        }
                    }
                },
                Err(e) => {
                    println!("\nError: couldn't connect to server!\n{}\n", e);
                }
            }
        },
        None => {
            println!("\nError : Failed to get input !");
        },
    }
        
    return String::from("")
}

fn scan(path: String, data: serde_json::Value) {
    println!("\nAnalyzing file...");
    match open_file(path) {
        Some(content) => {
            let hex_content = hex::encode(content);
            let mut score: i32 = 0;
            
            let mut keys_index: Vec<usize> = Vec::new();
            let mut index = 0;
            if let Some(keys) = data["keywords"].as_array() {
                let mut nbr: i32 = 0;
                for k in keys.iter() {
                    let mut k_string = k.to_string();
                    k_string.pop();
                    k_string.remove(0);
                    let hex_k = to_hex(k_string.clone());
                    let result = scan_contains(hex_content.clone(), hex_k);
                    if result {
                        if nbr == 0 {
                            println!("Keywords found :");
                        }
                        nbr += 1;
                        println!(" * {}", k_string.clone());
                        keys_index.push(index);
                    }
                    index += 1;
                }
            } else {
                println!("Error : failed to read keywords !");
            }

            if let Some(keys_score) = data["keywords_scores"].as_array() {
                for i in &keys_index {
                    let index = *i as usize; 
                    if index < keys_score.len() {
                        if let Some(value) = keys_score.get(index).and_then(|v| v.as_i64()) {
                            score += value as i32;
                        } else {
                            println!("Error : failed to convert the keywords scores at index {}.", index);
                        }
                    } else {
                    println!("Error: failed to open keywords scores at index {}.", index);
                    }
                }
            } else {
                println!("Error: failed to read keywords scores !");
            }
            
            let mut codes_index: Vec<usize> = Vec::new();
            let mut index = 0;    
            if let Some(codes) = data["shellcodes"].as_array() {
                let mut nbr: i32 = 0;
                for c in codes.iter() {
                    let mut c_string = c.to_string();
                    c_string.pop();
                    c_string.remove(0);
                    if scan_similarities(hex_content.clone(), c_string) > 0.9 {
                        nbr += 1;
                        codes_index.push(index);
                    }
                    index += 1;
                }
                if nbr > 0 {
                    println!("\n{} malicious shellcodes found.", nbr);
                }
            } else {
                println!("Error : failed to read shellcodes !");
            }

            if let Some(codes_score) = data["shellcodes_scores"].as_array() {
                for i in &codes_index {
                    let index = *i as usize; 
                    if index < codes_score.len() {
                        if let Some(value) = codes_score.get(index).and_then(|v| v.as_i64()) {
                            score += value as i32;
                        } else {
                            println!("Error : failed to convert the shellcodes scores at index {}.", index);
                        }
                    } else {
                    println!("Error: failed to open shellcodes scores at index {}.", index);
                    }
                }
            } else {
                println!("Error: failed to read shellcodes scores !");
            }
            
            println!("\nFinal score : {}", score);
            match score {
                0 ..= 5 => println!("Nothing to worry about."),
                6 ..= 9 => println!("Investigate this further."),
                _ => println!("Delete file !"),
            }
        },
        None => {
            println!("Error : failed to read file content !");
            return;
        },
    }
}

fn open_file(path: String) -> Option<Vec<u8>> {
    let mut file = match File::open(path) {
        Ok(file) => file,
        Err(_) => return None,
    };
    let mut buffer = Vec::new();
    
    return match file.read_to_end(&mut buffer) {
        Ok(_) => Some(buffer),
        Err(_) => None,
    }
}

fn get_input() -> Option<String> {
    let mut input = String::new();
    return match io::stdin().read_line(&mut input) {
        Ok(_) => {
            input.remove(input.len()-1);
            Some(input)
        }
        Err(e) => {
            println!(" Error : failed to get the input !\n{}\n", e);
            None
        }
    }
}

fn get_path() -> String {
    let mut path = String::from("");
    println!("\nEnter the full path to the file to be scanned :");
    print!(" >>> ");
    io::stdout().flush().unwrap();
    while !Path::new(&path).exists() {
        match get_input() {
            Some(input) => {
                path = String::from(input);
                break;
            },
            None => path = String::from(""),
        }
        println!("Error : file doesn't exist !");
    }
    
    return path;
}

fn scan_contains(file: String, to_find: String) -> bool {
    return file.contains(&to_find)
}

fn scan_similarities(file: String, to_find: String) -> f32 {
    return (lcs_length(file.clone(), to_find.clone())/to_find.len()) as f32;
}

fn to_hex(to_encode: String) -> String {
    hex::encode(to_encode)
}

fn menu_art() {
    println!("
      __  __       _                                                              
     |  \\/  |     | |                                                             
     | \\  / | __ _| |_      ____ _ _ __ ___   ___  ___ __ _ _ __  _ __   ___ _ __ 
     | |\\/| |/ _` | \\ \\ /\\ / / _` | '__/ _ \\ / __|/ __/ _` | '_ \\| '_ \\ / _ \\ '__|
     | |  | | (_| | |\\ V  V / (_| | | |  __/ \\__ \\ (_| (_| | | | | | | |  __/ |   
     |_|  |_|\\__,_|_| \\_/\\_/ \\__,_|_|  \\___| |___/\\___\\__,_|_| |_|_| |_|\\___|_|   
                                                                              
    ");
}
